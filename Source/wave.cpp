#include	"wave.h"

#include	"enemy.h"


/*******************************************************************************
TODO:03 WAVE管理クラスの初期化関数を定義する
説明    初期化関数では、必要なデータの初期値設定と
		オリジナルとなるモデルの読込を行う
--------------------------------------------------------------------------------
手順    以下の処理を実装せよ
		・「敵出現データ」に「敵設定構造体配列」を代入
		・「カウンタ」は0に
		・「現WAVE番号」も0に
		・全ての「オリジナルモデル配列」を初期化する
		・「文字列配列」を基にモデルのLoadを行う
		　但し、「文字列配列」の終端はNULLになっており、
		　仮に「モデル最大」以上あった場合は続きを無視する
*******************************************************************************/
void WaveManager::init(char** filename, Wave* wd)
{
	EnemyData = wd;
	count = 0;
	ThisWave = 0;
	intervalTimer = 60;

	for (int i = 0; i < model_max; i++)
	{
		myModel[i].Initialize();
	}
	for (int i = 0; i < model_max && filename[i]; i++)
	{
		myModel[i].Load(filename[i]);
	}
}

/*******************************************************************************
TODO:04 WAVE管理クラスの解放関数を定義する
説明    WAVE管理クラスの中で保持されているモデルデータを解放する
--------------------------------------------------------------------------------
手順    以下の処理を実装せよ
	・全ての「オリジナルモデル配列」を解放する
*******************************************************************************/
void WaveManager::release()
{
	//for (auto& model : myModel)
	//{
	//	model.Release();
	//}
	for (int i = 0; i < model_max; i++)
	{
		myModel[i].Release();
	}
}


/*******************************************************************************
TODO:05 WAVE管理クラスの生成関数を定義する
説明    生成関数では「敵出現データ」を基に敵を出現させるが、
		『「敵出現データ」はWAVE順に並び済みの物である』と前提する事で、
		毎フレーム出現データの全てをチェックする必要を無くす事ができる
--------------------------------------------------------------------------------
手順    以下の処理を実装せよ
		・現「カウンタ」の位置にあるデータの「WAVE番号」が負なら生成完了とし、falseを返す
		・現データの「WAVE番号」が「現WAVE番号」以下である間...
			・敵管理クラスを用いて敵設定処理を実行する
			　但し、ファイル名を指定する方式ではなく、「MyMesh型データ」を渡す事により、
			　MyMesh::SetMesh関数でモデルを使い回す形にする
			　また、座標、回転角度、色は現データから参照する
			・上記処理を行えるようにするために、敵管理クラス及び敵クラスを修正・追加する
			・現データと「カウンタ」を1つ増やす

		・データがまだ存在するので、trueを返す
*******************************************************************************/
bool WaveManager::create()
{
	Wave* d = &EnemyData[count];
	if (d->wave_num < 0) { return false; }

	while (d->wave_num >= 0 && d->wave_num <= ThisWave)
	{
		enemyManager.Set(myModel[d->model_num], DirectX::XMFLOAT3(d->pos_x, 0, d->pos_z), DirectX::XMConvertToRadians(d->angle), d->color);
		count++;
		d++;
	}
	return true;
}

